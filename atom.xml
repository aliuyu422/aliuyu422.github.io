<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一件小事</title>
  
  <subtitle>Say what you did.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-04T07:18:40.145Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Larryu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年5月的一些小事</title>
    <link href="http://yoursite.com/2020/06/04/2020%E5%B9%B45%E6%9C%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BA%8B/"/>
    <id>http://yoursite.com/2020/06/04/2020%E5%B9%B45%E6%9C%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BA%8B/</id>
    <published>2020-06-04T07:17:11.392Z</published>
    <updated>2020-06-04T07:18:40.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>达克效应：越是缺乏技能、能力和知识的人，往往越容易夸大自己的能力和知识。</p><a id="more"></a><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>连续加了一个月的班，五一没有休息，一个月一次双休，这个月一直做着一些运维的事情，偶尔做一些研发的活儿，每天会和领导打车来甲方爸爸这边现场支撑。单程三十公里，每天往返六十公里在路上，遇到偶尔堵车的周一和周五，会浪费一个小时在路上。</p><p>今年大势所趋，各个互联网公司都在裁员的背景下，本来已经很久没有做分内的工作，以为是要背上包劝退了，我竟然奇迹般的活到了现在？</p><p>对于未来的工作依然没有想法，没有想到一个合适的身份在这个社会立足，依旧是苟活在互联网的卑微仔，那么就做好当下的事情，持续观望吧！</p><h2 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h2><p>考研：身边二战考研和下一届的学弟学妹考研的成绩都在最近出来了，感觉大家都有勇气和干劲，很多朋友也都上了岸，当然也有遗憾落榜，每个人的选择都不一样，但是希望每个人对自己的选择负责和充满斗志。不患得患失，致敬命运。</p><p>贵阳：疫情后老姐也搬来贵阳顺利找到工作了，住在小区附近，偶尔可以和她出来谈谈人生理想，聊聊家里的秘密；偶尔也有老友路过贵阳，也有朋友时常关照，前阵子闲鱼上淘到的麻将机就派上用场了，凶多吉少。</p><h2 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h2><p>我现在应该长大了一些，不是那个虚拟世界都斗嘴必须分你上我下的性格了，好像慢慢知道这个世界上存在什么人都是合理的，然而与其把时间浪费在没有意义的重复争吵上，不如去看一看你还没有见过世界的其他面。</p><p>我不喜欢喧闹，是特别不喜欢在大庭广众之下可以起哄喧哗，不喜欢成为焦点，但是我很喜欢充满人间烟火味的集市，小区门口成两排的路边摊，各自有各自的喧闹，但是对于我也很宁静。</p><p>母亲节这天，吃完饭在园区坐着，恰好听见一个员工母亲和他儿子打电话，原来父母的思念都是藏在心里，欣慰都是在眼里。</p><p>坐在隧道开窗的车里，把耳机声音调到最大，闭着眼睛够着去听一些歌，以为能从中细品出异域风情，能够身同感受融化在其中，一些民歌，一些诗意，睁开眼刚出隧道的刹那眼睛还是被刚洒下的光刺穿，黑夜如此美好，人们却用来睡觉。</p><p>五月份身体先后出现一些些情况，先是脚受伤了，然后腹泻、头痛、落枕，镜框自然衰亡。拜拜了您！</p><p>下个月：看完一本书、加强运动、噩运消散！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;达克效应：越是缺乏技能、能力和知识的人，往往越容易夸大自己的能力和知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="live" scheme="http://yoursite.com/categories/live/"/>
    
    
      <category term="live" scheme="http://yoursite.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>几种真的很常见的跨域解决方案！</title>
    <link href="http://yoursite.com/2020/05/13/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/13/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-13T14:23:47.929Z</published>
    <updated>2020-05-13T14:25:32.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们默念文字的时候，那声音是谁的？</p><a id="more"></a><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>广义的理解：跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。<br>狭义的理解：是由浏览器同源策略限制的一类请求场景。</p><p>我们这里重点从狭义上去寻找几种常用的跨域解决方法。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略（SOP）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”<strong>协议+域名+端口</strong>“三者相同。</p><p><strong>举一些简单的栗子吧：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:www.baidu.com</span><br><span class="line">https:www.baidu.com</span><br><span class="line">非同源，因为协议不同</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu1.com/a.js</span><br><span class="line">http://www.baidu2.com/b.js </span><br><span class="line">非同源，因为域名不同</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com:8000/a.js</span><br><span class="line">http://www.baidu.com/b.js  </span><br><span class="line">非同源，因为端口不同</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/a.js</span><br><span class="line">http://www.baidu.com/b.js   </span><br><span class="line">http://www.baidu.com/test/c.js</span><br><span class="line">同源</span><br></pre></td></tr></table></figure><p>属于同源策略的才可以互相通信，否则需要做一些处理后才可以互换“资源”。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>1.使用jsonp解决跨域</strong></p><p><strong>原理</strong>：跨域访问的只限制xhr类型的请求，所以js中就利用了这一特点，让服务端不在返回的是一个JSON格式的数据，而是返回一段JS代码，将JSON的数据以参数的形式传递到这个函数中，而函数的名称就是callback参数的值。</p><p><strong>实现</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 处理跨域之前 AJAX正常的发送请求：</span><br><span class="line">$(&quot;#demo1&quot;).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url : &apos;http://www.tpadmin.top/Index/Test/crossDomain&apos;,</span><br><span class="line">        data : &#123;&#125;,</span><br><span class="line">        type : &apos;get&apos;,</span><br><span class="line">        success : function (res) &#123;</span><br><span class="line">            //No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://127.0.0.1&apos; is therefore not allowed access. 在执行时候报出的错误，这代表了跨域错误</span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 处理跨域  使用jsonp</span><br><span class="line">$(&quot;#demo2&quot;).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url : &apos;http://www.tpadmin.top/Index/Test/crossDomain&apos;,</span><br><span class="line">        data : &#123;&#125;,</span><br><span class="line">        type : &apos;get&apos;,</span><br><span class="line">        dataType : &apos;jsonp&apos;, </span><br><span class="line">        success : function (res) &#123;</span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ol><li>JSONP只支持GET请求，对POST请求不友好。</li><li>它只支持跨域HTTP请求。</li></ol><p><strong>2.使用CORS解决跨域</strong></p><p>CORS是一个W3C标准，全称是”<strong>跨域资源共享</strong>“。它允许浏览器向跨源服务器发出XMLHttpRequest请求。</p><p>此外，CORS需要浏览器和服务端同时支持，除了IE浏览器10版本以下的其他浏览器都已经支持，服务端和AJAX的原理类似，只需要在响应头里增加一些条件即可，一般通过过滤器完成。</p><p><strong>原理</strong>：浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。</p><p>（1）简单请求：需要满足两个条件。</p><ol><li>请求方法为POST GET HEAD三种的其中之一。</li><li>请求头中不存在自定义头，即只包含以下几个字段：<br>Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type( 值为 application/x-www-form-urlencoded、multipart/form-data、text/plain 其中之一 ）</li></ol><p>当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin.<br><img src="https://img-blog.csdnimg.cn/20200513200210588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p><p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://manage.leyou.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意；<br>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true。</p><p>如果跨域请求要想操作cookie，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax需要指定withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><p>（2）复杂请求：</p><p>如果不符合简单请求的要求，则判断为复杂请求，例如请求方式为PUT，会在正式通信之前进行一次HTTP查询请求，称为“预检请求”。</p><p>即：浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 复杂请求的请求头举例：</span><br><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://manage.leyou.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.leyou.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>服务器接收到“预检请求”，如果允许跨域，则会发出响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 复杂请求 允许跨域 的请求头举例：</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://manage.leyou.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的 ajax请求就无需再次进行预检了</li></ul><p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p><p><strong>实现</strong>：浏览器端已经实现了跨域，而在服务器端是通过统一拦截器实现的。</p><p>SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p><p>在Application下编写一个配置类，并且注册CorsFilter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line">import org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        //1.添加CORS配置信息</span><br><span class="line">        CorsConfiguration config = new CorsConfiguration();</span><br><span class="line">        //1) 允许的域,不要写*，否则cookie就无法使用了</span><br><span class="line">        config.addAllowedOrigin(&quot;http://manage.leyou.com&quot;);</span><br><span class="line">        //2) 是否发送Cookie信息</span><br><span class="line">        config.setAllowCredentials(true);</span><br><span class="line">        //3) 允许的请求方式</span><br><span class="line">        config.addAllowedMethod(&quot;OPTIONS&quot;);</span><br><span class="line">        config.addAllowedMethod(&quot;HEAD&quot;);</span><br><span class="line">        config.addAllowedMethod(&quot;GET&quot;);</span><br><span class="line">        config.addAllowedMethod(&quot;PUT&quot;);</span><br><span class="line">        config.addAllowedMethod(&quot;POST&quot;);</span><br><span class="line">        config.addAllowedMethod(&quot;DELETE&quot;);</span><br><span class="line">        config.addAllowedMethod(&quot;PATCH&quot;);</span><br><span class="line">        // 4）允许的头信息</span><br><span class="line">        config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        //2.添加映射路径，我们拦截一切请求</span><br><span class="line">        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;/**&quot;, config);</span><br><span class="line"></span><br><span class="line">        //3.返回新的CorsFilter.</span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.nginx反向代理接口跨域</strong></p><p><strong>原理</strong>：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p><strong>实现</strong>：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p> nginx具体配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码 举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>Node.js后台举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line"></span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure><p><strong>4.vue解决跨域</strong><br>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js 的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &apos;/login&apos;,</span><br><span class="line">            target: &apos;http://www.domain2.com:8080&apos;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们默念文字的时候，那声音是谁的？&lt;/p&gt;
    
    </summary>
    
    
      <category term="高频面试题" scheme="http://yoursite.com/categories/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="高频面试题" scheme="http://yoursite.com/tags/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>当我们输入网址后都发生了什么？！！</title>
    <link href="http://yoursite.com/2020/05/06/%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/05/06/%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/</id>
    <published>2020-05-06T13:04:07.165Z</published>
    <updated>2020-05-06T13:09:31.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们每天都在浏览器访问网页，但是在这短短的一秒，你难道不想知道它究竟经历了些什么？</p><a id="more"></a><h2 id="1-输入url："><a href="#1-输入url：" class="headerlink" title="1.输入url："></a>1.输入url：</h2><p>首先让我们来区别一下url、域名、网址的定义吧，例如：<a href="http://mail.163.com/index.html" target="_blank" rel="noopener">http://mail.163.com/index.html</a></p><ol><li>http://:这个是协议，也就是HTTP超文本传输协议，也就是网页在网上传输的协议。</li><li>mail：这个是服务器名，代表着是一个邮箱服务器，所以是mail.</li><li>163.com:这个是域名，是用来定位网站的独一无二的名字。</li><li>mail.163.com：这个是网站名，由服务器名+域名组成。</li><li>/：这个是根目录，也就是说，通过网站名找到服务器，然后在服务器存放网页的根目录</li><li>index.html：这个是根目录下的默认网页（当然，163的默认网页是不是这个我不知道，只是大部分的默认网页，都是index.html）</li><li><a href="http://mail.163.com/index.html:这个叫做URL，统一资源定位符，全球性地址，用于定位网上的资源。" target="_blank" rel="noopener">http://mail.163.com/index.html:这个叫做URL，统一资源定位符，全球性地址，用于定位网上的资源。</a></li></ol><h2 id="2-浏览器查找域名的ip地址"><a href="#2-浏览器查找域名的ip地址" class="headerlink" title="2.浏览器查找域名的ip地址"></a>2.浏览器查找域名的ip地址</h2><p>我们知道的去住酒店，都有一个房间号，这个房间号就好像是一个域名，对应到这个房间的地址。但是一般一个ip地址可以有多个域名，但是一个域名对应一个ip地址。</p><ul><li>查找浏览器缓存：浏览器一般会缓存DNS记录一段时间（谷歌浏览器大概12分钟左右），浏览器去查找这些缓存，如果有缓存，直接返回ip。</li><li>查找系统缓存：浏览器缓存中找不到IP之后，就会去查找本机的hosts文件，如果能找到，直接返回ip。</li><li>查找路由器缓存：路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP服务商缓存DNS的服务器，如果查找到ip则直接返回。</li><li>递归查询：ISP的DNS服务器会进行递归查询，所谓递归查询就是以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。</li><li>迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</li></ul><h2 id="3-浏览器与目标服务器建立TCP连接"><a href="#3-浏览器与目标服务器建立TCP连接" class="headerlink" title="3.浏览器与目标服务器建立TCP连接"></a>3.浏览器与目标服务器建立TCP连接</h2><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。<br>经典的TCP三次握手连接：<br><img src="https://img-blog.csdnimg.cn/20200506141352764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在TCP的三次握手"></p><h2 id="4-浏览器通过http协议发送请求"><a href="#4-浏览器通过http协议发送请求" class="headerlink" title="4.浏览器通过http协议发送请求"></a>4.浏览器通过http协议发送请求</h2><p><img src="https://img-blog.csdnimg.cn/20200506210049860.png" alt="在这里插入图片描述"></p><p>浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL ，KeepAlive，长连接，还有User-Agent用户浏览器操作系统信息，编码等。</p><p>这时，假如在学校的选课系统上，同时有很多人同时在请求访问，服务器肯定会出现崩溃的情况，这时候该如何是好。</p><blockquote><p>什么是反向代理服务器<br>客户端的本来可以直接通过HTTP协议访问应用服务器，但是网站管理员在中间添加了一个Nginx，这样客户端会先将请求发送到Nginx，Nginx请求应用服务器，然后将结果返回给客户端，Nginx就扮演着反向代理服务器器的角色。</p></blockquote><h2 id="5-服务器响应"><a href="#5-服务器响应" class="headerlink" title="5.服务器响应"></a>5.服务器响应</h2><p>服务器接收到获取请求，然后处理并返回一个响应。返回状态码200 OK，表示服务器可以响应请求，返回报文，浏览器以HTML形式呈现。</p><p>经过上面的几个步骤，服务器收到客户端请求，并已经处理，这时候需要把处理结果返回，也就是返回一个HTTP响应。<br>HTTP响应与HTTP请求类似，也包括如下三个部分：</p><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><p><img src="https://img-blog.csdnimg.cn/20200506204305637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>常用的状态码：</strong><br>1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 Continue</span><br><span class="line">101 Switching Protocols</span><br></pre></td></tr></table></figure><p>2xx：成功状态码，表示服务器已成功接收到请求并进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200 OK 表示客户端请求成功</span><br><span class="line">204 No Content 成功，但不返回任何实体的主体部分</span><br><span class="line">206 Partial Content 成功执行了一个范围（Range）请求</span><br></pre></td></tr></table></figure><p>3xx： 重定向状态码，表示服务器要求客户端重定向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</span><br><span class="line">302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</span><br><span class="line">303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</span><br><span class="line">304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</span><br><span class="line">307 Temporary Redirect 临时重定向。与302 Found含义一样。</span><br></pre></td></tr></table></figure><p>4xx：客户端错误状态码，表示客户端的请求有非法内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</span><br><span class="line">403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</span><br><span class="line">404 Not Found 请求的资源不存在，例如，输入了错误的URL</span><br></pre></td></tr></table></figure><p>5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</span><br><span class="line">503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</span><br></pre></td></tr></table></figure><h2 id="6-浏览器显示HTML"><a href="#6-浏览器显示HTML" class="headerlink" title="6.浏览器显示HTML"></a>6.浏览器显示HTML</h2><p><img src="https://img-blog.csdnimg.cn/20200506204701658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。</li><li>浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。</li><li>DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个NODE都有自己的style，而且 render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据CSS2的标准，render tree中的每个节点都称为Box (Box dimensions)，理解页面元素为一个具有填充、边距、边框和位置的盒子。</li><li>一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们每天都在浏览器访问网页，但是在这短短的一秒，你难道不想知道它究竟经历了些什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="高频面试题" scheme="http://yoursite.com/categories/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="高频面试题" scheme="http://yoursite.com/tags/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>vue原理篇——MVVM模式、响应式数据</title>
    <link href="http://yoursite.com/2020/05/05/vue%E5%8E%9F%E7%90%86%E7%AF%871/"/>
    <id>http://yoursite.com/2020/05/05/vue%E5%8E%9F%E7%90%86%E7%AF%871/</id>
    <published>2020-05-05T13:46:00.000Z</published>
    <updated>2020-05-05T13:48:16.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>三个奇怪的词：当我说“未来”这个词时，第一音发出后即成了过去，当我说寂静这个词，我打破了它，当我说“无”时，我在无中生有。</p><a id="more"></a><h3 id="MVVM模式的原理："><a href="#MVVM模式的原理：" class="headerlink" title="MVVM模式的原理："></a>MVVM模式的原理：</h3><p>传统的MVC模式的原理：开发人员将js代码分为了三个板块，数据(Model)、逻辑控制(Controller)、视图(View)，数据板块只负责数据部；,视图板块负责更改样式；逻辑控制负责联系视图板块和数据板块。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。</p><p><img src="https://img-blog.csdnimg.cn/20200505214113616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="MVC模式"></p><p>MVVM由：Model、View、ViewModel组成，不需要用户手动操作dom元素，而是将数据绑定到viewModel层上，会将数据渲染到界面中，同时视图的变化也会通知viewModel更新数据。</p><p><img src="https://img-blog.csdnimg.cn/2020050521412582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="MVVC模式"></p><h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>响应式数据原理的核心是<u>Object.defineProperty</u>。默认<code>Vue</code>在初始化数据时，会给<code>data</code>中的属性使用<code>Object.defineProperty</code>重新定义所有属性,当页面取到对应属性时。会进行<u>依赖收集</u>（收集当前组件的watcher） 如果属性发生变化会通知相关依赖进行更新操作。</p><ol><li>初始化用户传入的data数据| initData;</li><li>将数据进行观测 | new observer;</li><li>进行对象的处理 | this.walk;</li><li>循环对象属性，定义响应式变化 | define Reactive;</li><li>重新定义数据 | Object.defineProperty</li></ol><p>对应的源码如下：</p><ol><li><pre><code>Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      const value = getter ? getter.call(obj) : val      if (Dep.target) {        dep.depend() // ** 收集依赖 ** /        if (childOb) {          childOb.dep.depend()          if (Array.isArray(value)) {            dependArray(value)          }        }      }      return value    },    set: function reactiveSetter (newVal) {      const value = getter ? getter.call(obj) : val      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {        return      }      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) {        customSetter()      }      val = newVal      childOb = !shallow &amp;&amp; observe(newVal)      dep.notify() /**通知相关依赖进行更新**/    }  })</code></pre></li></ol><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三个奇怪的词：当我说“未来”这个词时，第一音发出后即成了过去，当我说寂静这个词，我打破了它，当我说“无”时，我在无中生有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>2020年4月的一些小事</title>
    <link href="http://yoursite.com/2020/05/04/2020%E5%B9%B44%E6%9C%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BA%8B/"/>
    <id>http://yoursite.com/2020/05/04/2020%E5%B9%B44%E6%9C%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BA%8B/</id>
    <published>2020-05-04T15:44:00.000Z</published>
    <updated>2020-05-04T15:49:03.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>2020年4月的一些小事：</strong></p><p>​刚刚，夏天一阵雨过后，够着鼻子去闻窗外的空气，是满足的味道都扑面而来。我想要的都如我所愿好像是很难得的事情。</p><a id="more"></a><p><strong>聚会见闻</strong></p><p>​清明节照惯例放了3天，由于疫情持续的原因，今年的湄潭还是不能去公墓祭奠。回家的三天见到了很多还没有去上学、放假回来的老友。我们都不再是同窗岁月的学生了，大家私底下各有各的烦恼、苦衷、丧气，但是一到聚在一起，什么都已经抛在了脑后。</p><p>在车上，我只是给他们提起下午要不要去我家吃饭，津威、弯锋、粉、老姐都给了面子。我家吃饭是很随意的，我和我妈两个人在家吃饭基本上都是一两个菜然后固定搭配大锅煮蔬菜。吃完饭后，大家似乎没有平时遇到家长那样的拘谨，就这样竟然嗨到十点过后，约上男神一起去拉拉家烧烤，就是一些翻来覆去的梗，和2月份返工那次在锅贴饺店一样。</p><p>​四月份开始，身边有很多人过生日。这次回去就赶上了弯锋过生日，提前了一天，因为第二天我要中午回贵阳，想我陪他喝酒。我才发现我们好像都慢慢长大了。</p><p>​如果在中学，我可能会去学校门口的天富礼品店买一个沙漏或者什么再包装一下送给他，高中我可能会在某宝上买一个精致的礼物寄给他，我们之间好像慢慢很少送别人这些仪式的礼物，上一次他寄给我的，还是一本数据结构的资料书。</p><p>​而现在，我想能够有时间去一下好朋友的生日聚会都已经很不容易了，我们彼此知道对方不会因为物质而疏远，想要的仅仅是难受的时候有你陪我醉一场，陪我打一场球，再陪我把那些心底的事情都说出来，哪怕在每一次酒醉后都是说的那个故事，是因为你我都清楚那是最难以忘怀的。</p><p>和朋友不同，父母的生日除了经常陪伴以外，我个人觉得还是需要一些仪式去证明。大学的时候会存一点她每个月给我的钱，会给她买一些可能还不常用的小礼物或是当地特产。父母总是表现得非常不在乎，可是她们却常常和朋友们说起，像是小时候我们向朋友们炫耀父母给我们买的玩具一样。</p><p><strong>婚姻思考</strong></p><p>先是大学在青协最好的搭档发了朋友圈领了证，他们还是他们，从校服走到婚姻，是再让人羡慕不过。再是大学最好的老乡同学已经生了宝宝，优秀的基因让我很少见到刚出生的高颜值婴儿。</p><p>​让我也开始觉得好像婚姻离我说远不远了。我好像真的很难再去从头了解一个人了，和校园恋爱也不一样，现实是可能更多的考虑各种条件，况且我好像也没有那么多想融入的圈子。</p><p>​在12岁的时候，我看结婚是有孩子的必经过程，是迈向一个阶段的通行证，更多的是一家子开启幸福旅程的车票；现在22岁丧丧的我，觉得结婚好像是绑架着道德和利益，是捆绑彼此心里缺乏的安全感，更多地是带着外人的期许如他们所愿。</p><p>​我遇不到正确的那个人，我可能不会选择结婚。</p><p><strong>拾起羽球</strong></p><p>​去年加了一个羽毛球的小组织，也因为疫情和工作加班的原因，很久没有去活动了，现在上起班来好像也没有太多锻炼的机会，工作之余的兴趣活动也是屈指可数，起因是群主问我能不能参加这次的春天杯，组织的每一次聚会好像都因为工作没能去。</p><p>​那几天工作量其实还是挺大的，而且又还都是一些棘手的问题，以至于有时候会失眠思考解决办法和早上醒来被自己问住，但是在打球的时候总是能够让我愉悦。</p><p><strong>重新出发</strong></p><p>​这个月很多互联网公司都传出了裁员的风声，一些大公司也不例外，今年毕业生难，考研难，我们刚刚毕业工作的程序员好像也很难，去年一起进来的同事纷纷都被发了“好人卡”，我好像也感受到了危机。</p><p>​不过我还在思考既然现在的工作不能使我快乐，我难道还要和它共度未来30年吗。像他说的那样，我可能不懂得30多岁的压力，但是我还有从头开始的勇气。我不惧怕被离开，我更愿意充实自己后，有能力主动去选择我自己的喜好，事事如此。</p><p><strong>定小目标</strong></p><p>1、体重控制到72kg</p><p>2、能够发两篇技术文。</p><p>3、前端知识能够整理串起来。</p><p>4、至少看完一本书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2020年4月的一些小事：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​刚刚，夏天一阵雨过后，够着鼻子去闻窗外的空气，是满足的味道都扑面而来。我想要的都如我所愿好像是很难得的事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="live" scheme="http://yoursite.com/categories/live/"/>
    
    
      <category term="live" scheme="http://yoursite.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>uniapp离线打包</title>
    <link href="http://yoursite.com/2019/06/28/uniapp%E7%A6%BB%E7%BA%BF%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2019/06/28/uniapp%E7%A6%BB%E7%BA%BF%E6%89%93%E5%8C%85/</id>
    <published>2019-06-28T14:36:00.000Z</published>
    <updated>2020-05-04T09:12:19.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-下载SDK"><a href="#1-下载SDK" class="headerlink" title="1.下载SDK"></a>1.下载SDK</h2><p><strong>链接:</strong> <a href="https://ask.dcloud.net.cn/article/103" target="_blank" rel="noopener">官方SDK下载链接</a>.</p><a id="more"></a><p>进入链接后可以找到最新的SDK，同时也可以在<strong>Android平台历史版本</strong>里面找到历史版本的SDK，可以根据自己的需要进行下载。</p><p><img src="https://img-blog.csdnimg.cn/20200313093002741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt></p><h2 id="2-打开Android-Studio"><a href="#2-打开Android-Studio" class="headerlink" title="2. 打开Android Studio"></a>2. 打开Android Studio</h2><p>导入你第1步下载的SDK 然后导入<br><img src="https://img-blog.csdnimg.cn/20200313095311348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200313095407612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此就已经完全引入项目了</p><p>然后在目录结构下打开 默认的资源目录www<br><img src="https://img-blog.csdnimg.cn/20200313095843300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这样就打开了 SDK默认项目的 资源目录（如下图）</p><p><img src="https://img-blog.csdnimg.cn/2020031310032929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>好啦，Android Studio这边暂时先保持这样一分钟，我们马上就回来！</p><h2 id="3-打开HbuilderX-编辑器"><a href="#3-打开HbuilderX-编辑器" class="headerlink" title="3.打开HbuilderX 编辑器"></a>3.打开HbuilderX 编辑器</h2><h3 id="3-1-生成本地打包资源"><a href="#3-1-生成本地打包资源" class="headerlink" title="3.1 生成本地打包资源"></a>3.1 生成本地打包资源</h3><p>在你对应的项目下进行本地打包，操作如下：</p><p><strong>发行</strong>—&gt;<strong>本地打包</strong>—-&gt;<strong>生成本地打包APP资源</strong><br><img src="https://img-blog.csdnimg.cn/20200313093535889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后在<strong>控制台</strong>可以看到生成资源在本机的路径并打开</p><p><img src="https://img-blog.csdnimg.cn/20200313094013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>打开后的目录往上走两级到<strong>resources</strong>下，然后会到下面这个目录</p><p><strong>复制这个文件夹，把它替换到第二步最后一步中Android Studio打开的那个目录 （替换掉HelloH5文件夹）</strong></p><p><img src="https://img-blog.csdnimg.cn/20200313100854451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-在Android-Studio中配置"><a href="#4-在Android-Studio中配置" class="headerlink" title="4. 在Android Studio中配置"></a>4. 在Android Studio中配置</h2><p>前面三步完成之后，在Android Studio中的项目目录可以看到这样</p><p><img src="https://img-blog.csdnimg.cn/20200313103008130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>修改各项配置：<br><strong>1.修改appid：</strong></p><p>如图打开<strong>dcloud_control.xml</strong> 文件修改<strong>appid</strong><br>需要和apps.xxx.www中的xxx相同，（也就是第三步最后一步中的那个文件夹名称）<br><img src="https://img-blog.csdnimg.cn/20200313101900691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.修改包名：</strong></p><p>在<strong>AndroiManifest.xml</strong>中修改<strong>package</strong>的值<br><img src="https://img-blog.csdnimg.cn/20200313102345184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在<strong>build.gradle</strong>总也要配置<strong>applicationId</strong>和 版本号<br><img src="https://img-blog.csdnimg.cn/20200313102613954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-打包"><a href="#5-打包" class="headerlink" title="5.打包"></a>5.打包</h2><p>在<strong>Build</strong>—-&gt;<strong>Generate Signed Budle</strong> 里面进行签名<br><img src="https://img-blog.csdnimg.cn/20200314150442485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果没有<strong>keystore</strong>需要<strong>Create new</strong></p><p><img src="https://img-blog.csdnimg.cn/20200314150526462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>本地生成自己的证书详情参考：<strong>链接:</strong> <a href="https://ask.dcloud.net.cn/article/35777#keyinfo" target="_blank" rel="noopener">本地生成自己的签名证书</a>.<br>uniapp官方的公共证书信息：<strong>链接:</strong> <a href="https://ask.dcloud.net.cn/article/36522" target="_blank" rel="noopener">官方提供的公共签名证书信息</a>.</p><p><img src="https://img-blog.csdnimg.cn/20200314151325149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>填写完信息后 点击“OK”</p><p><img src="https://img-blog.csdnimg.cn/2020031415053710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaXV5dTQyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>至此就可以完成离线打包了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-下载SDK&quot;&gt;&lt;a href=&quot;#1-下载SDK&quot; class=&quot;headerlink&quot; title=&quot;1.下载SDK&quot;&gt;&lt;/a&gt;1.下载SDK&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;链接:&lt;/strong&gt; &lt;a href=&quot;https://ask.dcloud.net.cn/article/103&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方SDK下载链接&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="app" scheme="http://yoursite.com/categories/app/"/>
    
    
      <category term="app" scheme="http://yoursite.com/tags/app/"/>
    
  </entry>
  
</feed>
